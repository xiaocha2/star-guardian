<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>像素星辰守护者 (Pixel Star Guardian)</title>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #000;
            color: #fff;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            font-family: 'Press Start 2P', cursive;
            overflow: hidden;
        }
        #game-container {
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }
        canvas {
            background-color: #080818;
            border: 2px solid #33f;
            box-shadow: 0 0 20px #33f;
            image-rendering: -moz-crisp-edges;
            image-rendering: -webkit-crisp-edges;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }
        #controls-info {
            margin-top: 15px;
            font-size: 12px;
            color: #aaa;
            text-align: center;
        }
    </style>
</head>
<body>
    <div id="game-container">
        <canvas id="gameCanvas"></canvas>
        <div id="controls-info">键盘: WASD/方向键 | 鼠标/触屏: 拖动</div>
    </div>

    <script>
        // --- 游戏设置与初始化 ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        let canvasWidth = 800;
        let canvasHeight = 600;

        function resizeCanvas() {
            const aspectRatio = 9 / 16; // 将画面调整为更窄的竖屏比例
            const screenWidth = window.innerWidth;
            const screenHeight = window.innerHeight;
            
            if (screenWidth / screenHeight > aspectRatio) {
                canvasHeight = screenHeight * 0.9;
                canvasWidth = canvasHeight * aspectRatio;
            } else {
                canvasWidth = screenWidth * 0.9;
                canvasHeight = canvasWidth / aspectRatio;
            }
            
            canvas.width = canvasWidth;
            canvas.height = canvasHeight;
            
            // 保持像素风格的清晰度
            ctx.imageSmoothingEnabled = false;
        }

        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        // 游戏状态管理
        const GAME_STATE = {
            START_SCREEN: 'START_SCREEN',
            PLAYING: 'PLAYING',
            WAVE_TRANSITION: 'WAVE_TRANSITION',
            GAME_OVER: 'GAME_OVER',
            VICTORY: 'VICTORY',
            HIGH_SCORES_SCREEN: 'HIGH_SCORES_SCREEN' // 新增高分榜状态
        };
        let gameState = GAME_STATE.START_SCREEN;
        let previousGameState = GAME_STATE.START_SCREEN; // 新增变量以记录先前状态


        // 玩家输入
        let keys = {};
        const mouse = { x: canvas.width / 2, y: canvas.height / 1.1, down: false };
        let controlMode = 'keyboard'; // 'keyboard' or 'mouse'

        window.addEventListener('keydown', (e) => {
            keys[e.key] = true;
            controlMode = 'keyboard';
        });
        window.addEventListener('keyup', (e) => {
            keys[e.key] = false;
        });
        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            mouse.x = (e.clientX - rect.left) / (rect.right - rect.left) * canvas.width;
            mouse.y = (e.clientY - rect.top) / (rect.bottom - rect.top) * canvas.height;
            controlMode = 'mouse';
        });
        canvas.addEventListener('click', handleMenuClick);

        // --- 触屏控制 ---
        function handleTouch(e) {
            if (e.touches) {
                e.preventDefault(); // 阻止页面滚动
                controlMode = 'mouse'; // 复用鼠标移动逻辑
                const rect = canvas.getBoundingClientRect();
                const touch = e.touches[0];
                mouse.x = (touch.clientX - rect.left) / (rect.right - rect.left) * canvas.width;
                mouse.y = (touch.clientY - rect.top) / (rect.bottom - rect.top) * canvas.height;
            }
        }
        canvas.addEventListener('touchstart', handleTouch, { passive: false });
        canvas.addEventListener('touchmove', handleTouch, { passive: false });


        // --- 音效设置 ---
        let hitSynth, powerUpSynth;
        let audioInitialized = false;

        function initializeAudio() {
            if (audioInitialized) return;
            // 击中音效
            hitSynth = new Tone.MembraneSynth({
                pitchDecay: 0.05,
                octaves: 10,
                oscillator: { type: 'sine' },
                envelope: { attack: 0.001, decay: 0.4, sustain: 0.01, release: 1.4, attackCurve: 'exponential' }
            }).toDestination();

            // 道具拾取音效
            powerUpSynth = new Tone.FMSynth({
                harmonicity: 3.01,
                modulationIndex: 14,
                detune: 0,
                oscillator: { type: 'triangle' },
                envelope: { attack: 0.01, decay: 0.2, sustain: 0.01, release: 0.5 },
                modulation: { type: 'square' },
                modulationEnvelope: { attack: 0.01, decay: 0.3, sustain: 0.01, release: 0.5 }
            }).toDestination();
            
            audioInitialized = true;
        }

        function playHitSound() {
            if (!audioInitialized) return;
            hitSynth.triggerAttackRelease('C2', '8n', Tone.now());
        }

        function playPowerUpSound() {
            if (!audioInitialized) return;
            powerUpSynth.triggerAttackRelease('C5', '8n', Tone.now());
        }


        // 游戏变量
        let score = 0;
        let baseHp = 5; // 新增基地生命值
        let maxBaseHp = 5; // 新增基地最大生命值
        let currentWave = 0;
        let waveTransitionTimer = 0;
        const WAVE_TRANSITION_DELAY = 180;
        let waveSpawners = [];
        let powerUpSpawnTimer = 600; // 道具生成计时器 (10秒)
        const POWERUP_SPAWN_INTERVAL = 600;


        let player;
        let bullets = [];
        let enemies = [];
        let enemyBullets = [];
        let powerUps = [];
        let particles = [];
        let backgroundStars = [];
        let backgroundNebulas = [];
        let backgroundAsteroids = [];

        // --- 实体类定义 ---

        // 玩家类
        class Player {
            constructor() {
                this.width = 32;
                this.height = 32;
                this.x = canvas.width / 2 - this.width / 2;
                this.y = canvas.height - this.height - 30;
                this.speed = 5;
                this.hp = 5;
                this.maxHp = 5;
                this.shootCooldown = 0;
                this.shootInterval = 10;
                this.invulnerableTimer = 0;
                this.invulnerableDuration = 120; // 2秒无敌
                
                // 道具效果
                this.shield = 0;
                this.powerUpTimers = {
                    multiShot: 0,
                    laser: 0,
                    fireRate: 0 // 新增射速提升计时器
                };
            }

            draw() {
                ctx.save();
                if (this.invulnerableTimer > 0 && Math.floor(this.invulnerableTimer / 6) % 2 === 0) {
                    ctx.globalAlpha = 0.5;
                }
                
                // 绘制飞船主体
                ctx.fillStyle = '#cccccc'; // 白色
                ctx.fillRect(this.x + 12, this.y, 8, 20); // 中间机身
                ctx.fillStyle = '#aaaaaa'; // 深灰色
                ctx.fillRect(this.x, this.y + 8, 12, 16); // 左翼
                ctx.fillRect(this.x + 20, this.y + 8, 12, 16); // 右翼

                // 绘制能量线条和驾驶舱
                ctx.fillStyle = '#00ffff'; // 青色
                ctx.fillRect(this.x + 14, this.y + 4, 4, 8); // 驾驶舱
                ctx.fillRect(this.x, this.y + 10, 2, 12); // 左翼线条
                ctx.fillRect(this.x + 30, this.y + 10, 2, 12); // 右翼线条

                // 如果激光道具激活，绘制光束
                if (this.powerUpTimers.laser > 0) {
                    const beamWidth = 8;
                    ctx.fillStyle = '#ffffff';
                    ctx.fillRect(this.x + this.width / 2 - beamWidth / 2, 0, beamWidth, this.y);
                    ctx.fillStyle = 'rgba(0, 255, 255, 0.5)';
                    ctx.fillRect(this.x + this.width / 2 - beamWidth / 2 - 2, 0, beamWidth + 4, this.y);
                }

                // 绘制护盾
                if (this.shield > 0) {
                    ctx.strokeStyle = `rgba(0, 255, 255, ${0.5 + this.shield * 0.15})`;
                    ctx.lineWidth = 1 + this.shield;
                    ctx.beginPath();
                    ctx.arc(this.x + this.width / 2, this.y + this.height / 2, this.width, 0, Math.PI * 2);
                    ctx.stroke();
                }

                ctx.restore();
            }

            update() {
                // 处理移动
                if (controlMode === 'keyboard') {
                    if (keys['w'] || keys['ArrowUp']) this.y -= this.speed;
                    if (keys['s'] || keys['ArrowDown']) this.y += this.speed;
                    if (keys['a'] || keys['ArrowLeft']) this.x -= this.speed;
                    if (keys['d'] || keys['ArrowRight']) this.x += this.speed;
                } else { // mouse or touch control
                    const targetX = mouse.x - this.width / 2;
                    const targetY = mouse.y - this.height / 2;
                    // A higher factor makes the ship follow the touch/mouse faster
                    this.x += (targetX - this.x) * 0.25;
                    this.y += (targetY - this.y) * 0.25;
                }

                // 边界限制
                this.x = Math.max(0, Math.min(canvas.width - this.width, this.x));
                this.y = Math.max(0, Math.min(canvas.height - this.height, this.y));

                // 处理射击
                this.shoot();
                if (this.shootCooldown > 0) this.shootCooldown--;
                
                // 处理无敌计时器
                if (this.invulnerableTimer > 0) this.invulnerableTimer--;

                // 处理道具计时器
                for (const key in this.powerUpTimers) {
                    if (this.powerUpTimers[key] > 0) {
                        this.powerUpTimers[key]--;
                    } 
                }
                
                // 引擎粒子效果
                if(Math.random() < 0.5) {
                    particles.push(new Particle(this.x + this.width / 2 - 4, this.y + this.height, 2, '#00ffff', 0, 3, 20));
                    particles.push(new Particle(this.x + this.width / 2 + 4, this.y + this.height, 2, '#00ffff', 0, 3, 20));
                }
            }

            shoot() {
                // 当激光激活时，飞船不发射普通子弹
                if (this.powerUpTimers.laser > 0) {
                    return;
                }

                let currentShootInterval = 15;
                if(this.powerUpTimers.multiShot > 0) currentShootInterval = 12;
                if(this.powerUpTimers.fireRate > 0) currentShootInterval = Math.floor(currentShootInterval / 2); // 射速加倍

                if (this.shootCooldown === 0) {
                    // 多重射击
                    if (this.powerUpTimers.multiShot > 0) {
                        // 改为散射3道子弹
                        bullets.push(new Bullet(this.x + this.width / 2, this.y, 4, 12, -10, 'player', 0)); // 中间
                        bullets.push(new Bullet(this.x + this.width / 2, this.y, 4, 12, -9, 'player', -2)); // 左
                        bullets.push(new Bullet(this.x + this.width / 2, this.y, 4, 12, -9, 'player', 2)); // 右
                    } 
                    // 普通射击
                    else {
                        bullets.push(new Bullet(this.x + this.width / 2, this.y, 4, 12, -10));
                    }
                    this.shootCooldown = currentShootInterval;
                }
            }
            
            takeDamage() {
                if (this.invulnerableTimer > 0) return;

                if (this.shield > 0) {
                    this.shield--;
                    this.invulnerableTimer = 60; // 受伤后短暂无敌
                    return;
                }

                this.hp--;
                this.invulnerableTimer = this.invulnerableDuration;
                if (this.hp <= 0) {
                    gameState = GAME_STATE.GAME_OVER;
                    addHighScore(score); // 游戏结束时记录分数
                    createExplosion(this.x + this.width / 2, this.y + this.height / 2, '#00ffff', 50);
                }
            }
        }

        // 子弹类
        class Bullet {
            constructor(x, y, width, height, speedY, type = 'player', speedX = 0) {
                this.x = x - width / 2;
                this.y = y;
                this.width = width;
                this.height = height;
                this.speedY = speedY;
                this.speedX = speedX;
                this.type = type;
                this.markedForDeletion = false;
            }

            draw() {
                if (this.type === 'player') {
                    ctx.fillStyle = '#00ffff';
                    ctx.fillRect(this.x, this.y, this.width, this.height);
                    // 辉光效果
                    ctx.fillStyle = 'rgba(0, 255, 255, 0.3)';
                    ctx.fillRect(this.x - 2, this.y - 2, this.width + 4, this.height + 4);
                } else { // 敌方子弹
                    ctx.fillStyle = '#ff4444';
                    ctx.fillRect(this.x, this.y, this.width, this.height);
                    // 辉光效果
                    ctx.fillStyle = 'rgba(255, 68, 68, 0.3)';
                    ctx.fillRect(this.x - 2, this.y - 2, this.width + 4, this.height + 4);
                }
            }

            update() {
                this.y += this.speedY;
                this.x += this.speedX;
                if (this.y < -this.height || this.y > canvas.height) {
                    this.markedForDeletion = true;
                }
            }
        }

        // 敌人基类
        class Enemy {
            constructor(x, y, width, height, hp, scoreValue) {
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
                this.hp = hp;
                this.maxHp = hp;
                this.scoreValue = scoreValue;
                this.markedForDeletion = false;
            }
            
            takeDamage(damage) {
                this.hp -= damage;
                if (this.hp <= 0) {
                    this.markedForDeletion = true;
                    score += this.scoreValue;
                    createExplosion(this.x + this.width / 2, this.y + this.height / 2, '#ff8c00');
                    playHitSound();
                }
                return true; // 默认情况下，攻击有效，子弹应被销毁
            }

            update() {
                if (this.speedY) this.y += this.speedY;
                if (this.speedX) this.x += this.speedX;
                if (this.y > canvas.height) this.markedForDeletion = true;
            }
        }

        class PulseScout extends Enemy {
             constructor(x, y, waveNum = 1) {
                super(x, y, 28, 24, 2, 100);
                this.waveNum = waveNum; // Store wave number on the instance
                this.speedY = (1.5 + (this.waveNum * 0.05));
                this.speedX = 0;
                this.shootCooldown = Math.max(90, 160 - (this.waveNum * 5));
            }
            draw() {
                // 碟形设计
                ctx.fillStyle = '#8a2be2'; // 深紫色
                ctx.fillRect(this.x, this.y + 8, 28, 8); // 主体
                ctx.fillRect(this.x + 4, this.y + 4, 20, 16);
                ctx.fillRect(this.x + 8, this.y, 12, 24);
                // 舷窗
                ctx.fillStyle = '#90ee90'; // 柔和绿光
                ctx.fillRect(this.x + 8, this.y + 10, 4, 4);
                ctx.fillRect(this.x + 16, this.y + 10, 4, 4);
            }
            update() {
                this.y += this.speedY;
                if (this.y > canvas.height) {
                    this.markedForDeletion = true;
                    handleBaseDamage();
                }

                if (this.shootCooldown > 0) {
                    this.shootCooldown--;
                } else {
                    const bulletSpeed = (3.5 + (this.waveNum * 0.1));
                    const dx = (player.x + player.width / 2) - (this.x + this.width / 2);
                    const dy = (player.y + player.height / 2) - (this.y + this.height / 2);
                    const angle = Math.atan2(dy, dx);
                    const speedX = Math.cos(angle) * bulletSpeed;
                    const speedY = Math.sin(angle) * bulletSpeed;
                    enemyBullets.push(new Bullet(this.x + this.width/2, this.y + this.height, 6, 6, speedY, 'enemy', speedX));
                    this.shootCooldown = Math.max(90, 160 - (this.waveNum * 5)); 
                }
            }
        }

        class KamikazeDrone extends Enemy {
            constructor(x, y, waveNum = 1) {
                super(x, y, 20, 20, 1, 50);
                this.speedY = (3.5 + (waveNum * 0.2));
            }
            draw() {
                // 箭头形状
                ctx.fillStyle = '#808080'; // 金属灰
                ctx.beginPath();
                ctx.moveTo(this.x, this.y);
                ctx.lineTo(this.x + this.width, this.y);
                ctx.lineTo(this.x + this.width / 2, this.y + this.height);
                ctx.closePath();
                ctx.fill();
                // 红色灯带
                ctx.fillStyle = Math.random() < 0.5 ? '#ff0000' : '#aa0000';
                ctx.fillRect(this.x + this.width / 2 - 2, this.y + 4, 4, 12);
            }
            update() {
                this.y += this.speedY;
                if (this.y > canvas.height) {
                    this.markedForDeletion = true;
                    handleBaseDamage();
                }
            }
        }
        
        class SpiralFighter extends Enemy {
            constructor(x, y, waveNum = 1) {
                super(x, y, 30, 24, 4, 250);
                this.speedY = (2 + (waveNum * 0.1));
                this.angle = Math.random() * Math.PI * 2;
                this.amplitude = Math.random() * 50 + 20;
                this.frequency = 0.05;
                this.shootCooldown = (Math.random() * 120 + 80);
                this.burstCount = 0;
            }
            draw() {
                // 黄蜂形状
                ctx.fillStyle = '#ffd700'; // 亮黄
                ctx.fillRect(this.x, this.y + 4, 30, 16);
                ctx.fillStyle = '#000000'; // 黑色条纹
                ctx.fillRect(this.x + 8, this.y + 4, 4, 16);
                ctx.fillRect(this.x + 18, this.y + 4, 4, 16);
                // 机翼
                ctx.fillStyle = 'rgba(0, 255, 255, 0.5)';
                ctx.fillRect(this.x - 4, this.y, 8, 24);
                ctx.fillRect(this.x + 26, this.y, 8, 24);
                // 眼睛
                ctx.fillStyle = '#ff0000';
                ctx.fillRect(this.x + 4, this.y+8, 4, 4);
                ctx.fillRect(this.x + 22, this.y+8, 4, 4);
            }
            update() {
                this.y += this.speedY;
                this.x += Math.sin(this.angle) * 2;
                this.angle += this.frequency;

                if (this.y > canvas.height) {
                    this.markedForDeletion = true;
                    handleBaseDamage();
                }

                if (this.shootCooldown > 0) {
                    this.shootCooldown--;
                } else {
                    if (this.burstCount < 2) { // 减少连发数量以平衡
                         const bulletSpeed = (4 + (currentWave * 0.1));
                         const dx = (player.x + player.width / 2) - (this.x + this.width / 2);
                         const dy = (player.y + player.height / 2) - (this.y + this.height / 2);
                         const angle = Math.atan2(dy, dx);
                         const speedX = Math.cos(angle) * bulletSpeed;
                         const speedY = Math.sin(angle) * bulletSpeed;
                         enemyBullets.push(new Bullet(this.x + this.width/2, this.y + this.height, 5, 5, speedY, 'enemy', speedX));
                         this.burstCount++;
                         this.shootCooldown = 10; // 连发间隔
                    } else {
                        this.burstCount = 0;
                        this.shootCooldown = Math.max(120, 200 - (currentWave * 6)); // 下一轮连发
                    }
                }
            }
        }

        // 新增敌人 1: 幽灵截击机
        class GhostInterceptor extends Enemy {
            constructor(x, y, waveNum = 1) {
                super(x, y, 26, 26, 3, 300);
                this.speedY = (1.8 + (waveNum * 0.1));
                this.speedX = ((Math.random() < 0.5 ? -1 : 1) * (2 + waveNum * 0.1));
                this.alpha = 1;
                this.blinkTimer = 120 + Math.random() * 60; // 2-3秒闪烁一次
                this.shootCooldown = 240;
            }
            draw() {
                ctx.save();
                ctx.globalAlpha = this.alpha;
                ctx.fillStyle = '#9400d3'; // 紫罗兰色
                // 绘制一个类似幽灵的形状
                ctx.beginPath();
                ctx.moveTo(this.x + this.width / 2, this.y);
                ctx.lineTo(this.x + this.width, this.y + this.height * 0.7);
                ctx.lineTo(this.x + this.width / 2, this.y + this.height);
                ctx.lineTo(this.x, this.y + this.height * 0.7);
                ctx.closePath();
                ctx.fill();
                // 眼睛
                ctx.fillStyle = '#fff';
                ctx.fillRect(this.x + this.width / 2 - 2, this.y + this.height * 0.4, 4, 4);
                ctx.restore();
            }
            update() {
                this.y += this.speedY;
                this.x += this.speedX;

                if (this.x <= 0 || this.x >= canvas.width - this.width) {
                    this.speedX *= -1;
                }

                this.blinkTimer--;
                if (this.blinkTimer <= 0) {
                    // 随机传送到一个新的水平位置
                    this.x = Math.random() * (canvas.width - this.width);
                    this.blinkTimer = 180 + Math.random() * 120; // 3-5秒后再次传送
                    this.alpha = 0; // 传送后短暂不可见
                }

                if (this.alpha < 1) {
                    this.alpha += 0.05; // 慢慢现形
                }

                if (this.shootCooldown > 0) {
                    this.shootCooldown--;
                } else if (this.alpha >= 1) { // 完全现形后才射击
                    const speed = (3.5 + currentWave * 0.1);
                    const dx = player.x - this.x;
                    const dy = player.y - this.y;
                    const angle = Math.atan2(dy, dx);
                    enemyBullets.push(new Bullet(this.x + this.width/2, this.y + this.height/2, 8, 8, Math.sin(angle) * speed, 'enemy', Math.cos(angle) * speed));
                    this.shootCooldown = 240;
                }
                
                if (this.y > canvas.height) {
                    this.markedForDeletion = true;
                    handleBaseDamage();
                }
            }
        }

        // 新增敌人 2: 屏障哨兵
        class BarrierSentinel extends Enemy {
            constructor(x, y, waveNum = 1) {
                super(x, y, 60, 40, 15, 800);
                this.speedY = (0.4 + (waveNum * 0.02));
                this.shootCooldown = 200;
            }
            draw() {
                // 绘制机体
                ctx.fillStyle = '#708090'; // 石板灰
                ctx.fillRect(this.x, this.y, this.width, this.height);
                ctx.fillStyle = '#556677';
                ctx.fillRect(this.x + 5, this.y + 5, this.width - 10, this.height - 10);
                
                // 绘制正面护盾
                ctx.fillStyle = 'rgba(0, 191, 255, 0.4)';
                ctx.fillRect(this.x, this.y, this.width, 10);
                 ctx.fillStyle = 'rgba(0, 191, 255, 0.8)';
                ctx.fillRect(this.x, this.y, this.width, 3);
            }
            update() {
                this.y += this.speedY;

                if (this.shootCooldown > 0) {
                    this.shootCooldown--;
                } else {
                    // 扇形弹幕现在会瞄准玩家
                    const bulletSpeed = 2.5;
                    const dx = (player.x + player.width / 2) - (this.x + this.width / 2);
                    const dy = (player.y + player.height / 2) - (this.y + this.height);
                    const centerAngle = Math.atan2(dy, dx);
                    const spread = 0.3; // 弧度
                    for (let i = -2; i <= 2; i++) {
                        const angle = centerAngle + (i * spread);
                        const speedX = Math.cos(angle) * bulletSpeed;
                        const speedY = Math.sin(angle) * bulletSpeed;
                        enemyBullets.push(new Bullet(this.x + this.width / 2, this.y + this.height, 6, 6, speedY, 'enemy', speedX));
                    }
                    this.shootCooldown = Math.max(120, 180 - (currentWave * 4));
                }
                if (this.y > canvas.height) {
                    this.markedForDeletion = true;
                    handleBaseDamage();
                }
            }
            takeDamage(damage, bullet) {
                // 检查子弹是否从正面击中
                if (bullet && bullet.y < this.y + 10) {
                    // 击中护盾，无效
                    particles.push(new Particle(bullet.x, this.y + 5, 2, '#00bfff', 0, 0, 10));
                    return false;
                }
                return super.takeDamage(damage);
            }
        }

        // 新增敌人 3: 集群无人机
        class SwarmMinion extends Enemy {
            constructor(x, y, waveNum = 1, swarmLeader) {
                super(x, y, 12, 12, 1, 20);
                this.swarmLeader = swarmLeader; // 跟随一个虚拟的领导点
                this.offsetX = x - swarmLeader.x;
                this.offsetY = y - swarmLeader.y;
            }
            draw() {
                ctx.fillStyle = '#dc143c'; // 猩红色
                ctx.fillRect(this.x, this.y, this.width, this.height);
                 ctx.fillStyle = '#ff6347'; 
                ctx.fillRect(this.x+2, this.y+2, this.width-4, this.height-4);
            }
            update() {
                // 跟随领导点移动
                if (this.swarmLeader.markedForDeletion) {
                    this.markedForDeletion = true;
                    return;
                }
                this.x = this.swarmLeader.x + this.offsetX;
                this.y = this.swarmLeader.y + this.offsetY;

                if (this.y > canvas.height) {
                    this.markedForDeletion = true;
                    handleBaseDamage();
                }
            }
        }
        
        class HeavyCruiser extends Enemy {
            constructor(x, y, waveNum = 1) {
                super(x, y, 80, 50, 20, 1000);
                this.speedY = (0.5 + (waveNum * 0.05));
                this.shootCooldown = Math.max(120, 180 - (waveNum * 4));
            }
            draw() {
                ctx.fillStyle = '#464646'; // 炮舰灰
                ctx.fillRect(this.x, this.y, 80, 50);
                ctx.fillStyle = '#303030';
                ctx.fillRect(this.x + 10, this.y - 5, 60, 10); // 舰桥
                ctx.fillRect(this.x + 5, this.y + 5, 70, 40); // 装甲细节
                // 炮塔
                ctx.fillStyle = '#606060';
                ctx.fillRect(this.x, this.y + 10, 10, 20); // 左炮塔
                ctx.fillRect(this.x + 70, this.y + 10, 10, 20); // 右炮塔
                
                // 开火前充能效果
                if (this.shootCooldown < 30) {
                    const glow = Math.floor(this.shootCooldown / 5) % 2 === 0;
                    if(glow){
                        ctx.fillStyle = '#ffa500';
                        ctx.fillRect(this.x, this.y + 15, 10, 10);
                        ctx.fillRect(this.x + 70, this.y + 15, 10, 10);
                    }
                }
            }
            update() {
                this.y += this.speedY;
                if (this.y > canvas.height) {
                    this.markedForDeletion = true;
                    handleBaseDamage();
                }

                if (this.shootCooldown > 0) {
                    this.shootCooldown--;
                } else {
                    // 扇形弹幕现在会瞄准玩家
                    const bulletSpeed = (2.5 + (currentWave * 0.1));
                    const dx = (player.x + player.width / 2) - (this.x + this.width / 2);
                    const dy = (player.y + player.height / 2) - (this.y + this.height);
                    const centerAngle = Math.atan2(dy, dx);
                    const spread = 0.3; // 弧度
                    for (let i = -2; i <= 2; i++) {
                        const angle = centerAngle + (i * spread);
                        const speedX = Math.cos(angle) * bulletSpeed;
                        const speedY = Math.sin(angle) * bulletSpeed;
                        enemyBullets.push(new Bullet(this.x + this.width / 2, this.y + this.height, 6, 6, speedY, 'enemy', speedX));
                    }
                    this.shootCooldown = Math.max(120, 180 - (currentWave * 4));
                }
            }
        }

        // --- Bosses ---

        // 小Boss 1: 堡垒
        class Juggernaut extends Enemy {
            constructor(x, y) {
                super(x, y, 120, 80, 0, 5000); // HP会根据炮台计算
                this.speedY = 0.2;
                this.speedX = 0.8;
                this.turrets = [
                    { x: 0, y: 30, hp: 8, maxHp: 8, cooldown: 90, timer: 90, destroyed: false }, // 血量x2
                    { x: 100, y: 30, hp: 8, maxHp: 8, cooldown: 90, timer: 90, destroyed: false } // 血量x2
                ];
                this.hp = this.turrets.reduce((sum, t) => sum + t.hp, 0);
                this.maxHp = this.hp;
            }
            draw() {
                // 主体
                ctx.fillStyle = '#4a4a4a';
                ctx.fillRect(this.x + 20, this.y, 80, 80);
                ctx.fillStyle = '#333';
                ctx.fillRect(this.x + 30, this.y + 10, 60, 60);
                // 红色警示灯
                ctx.fillStyle = Math.random() < 0.5 ? '#f00' : '#a00';
                ctx.fillRect(this.x + 55, this.y + 35, 10, 10);
                // 炮台
                this.turrets.forEach(turret => {
                    if (!turret.destroyed) {
                        ctx.fillStyle = '#888';
                        ctx.fillRect(this.x + turret.x, this.y + turret.y, 20, 30);
                        ctx.fillStyle = '#666';
                        ctx.fillRect(this.x + turret.x + 5, this.y + turret.y, 10, 20);
                    }
                });
            }
            update() {
                if(this.y < 40) this.y += this.speedY;

                this.x += this.speedX;
                if(this.x < 20 || this.x > canvas.width - this.width - 20) {
                    this.speedX *= -1;
                }


                this.turrets.forEach(turret => {
                    if (!turret.destroyed) {
                        turret.timer--;
                        if (turret.timer <= 0) {
                            const bulletSpeed = 3;
                            const startX = this.x + turret.x + 10;
                            const startY = this.y + turret.y + 30;
                            const dx = (player.x + player.width / 2) - startX;
                            const dy = (player.y + player.height / 2) - startY;
                            const centerAngle = Math.atan2(dy, dx);
                            const spread = 0.4; // 弧度
                            for (let i = -1; i <= 1; i++) {
                                const angle = centerAngle + (i * spread);
                                const speedX = Math.cos(angle) * bulletSpeed;
                                const speedY = Math.sin(angle) * bulletSpeed;
                                enemyBullets.push(new Bullet(startX, startY, 6, 6, speedY, 'enemy', speedX));
                            }
                            turret.timer = turret.cooldown;
                        }
                    }
                });
            }
            takeDamage(damage, bullet) {
                let bulletConsumed = false;

                // 检查炮台（弱点）
                this.turrets.forEach(turret => {
                    if (!turret.destroyed && bullet && checkCollision(bullet, { x: this.x + turret.x, y: this.y + turret.y, width: 20, height: 30 })) {
                        turret.hp -= damage;
                        this.hp -= damage; 
                        if (turret.hp <= 0) {
                            turret.destroyed = true;
                            createExplosion(this.x + turret.x + 10, this.y + turret.y + 15, '#ff8c00', 30);
                            score += 1000;
                            playHitSound();
                        }
                        bulletConsumed = true;
                    }
                });

                if (bulletConsumed) {
                    if (this.hp <= 0) super.takeDamage(999);
                    return true;
                }

                // 如果没有击中炮台，检查主体
                if (bullet && checkCollision(bullet, this)) {
                    this.hp -= damage * 0.5; // 主体受到一半伤害
                    particles.push(new Particle(bullet.x, bullet.y, 2, '#aaa', 0, 0, 10)); 
                    if (this.hp <= 0) super.takeDamage(999);
                    return true; 
                }

                // 激光伤害（没有实体子弹对象）
                if (!bullet) {
                     this.hp -= damage;
                     if (this.hp <= 0) super.takeDamage(999);
                }

                return false;
            }
        }

        // 小Boss 2: 幻影
        class Phantom extends Enemy {
            constructor(x, y) {
                super(x, y, 60, 60, 24, 7500); // 血量x2
                this.teleportTimer = 180;
                this.shootTimer = 60;
                this.alpha = 1;
            }
            draw() {
                ctx.save();
                ctx.globalAlpha = this.alpha;
                
                // 能量环
                ctx.fillStyle = '#ff00ff'; 
                ctx.beginPath();
                ctx.arc(this.x + this.width / 2, this.y + this.height / 2, this.width / 2, 0, Math.PI * 2);
                ctx.fill();

                // 核心
                ctx.fillStyle = '#4b0082';
                ctx.fillRect(this.x + 15, this.y + 15, 30, 30);
                // 核心的"眼睛"
                 ctx.fillStyle = '#fff';
                ctx.fillRect(this.x + 27, this.y + 20, 6, 12);


                ctx.restore();
            }
            update() {
                this.teleportTimer--;
                if (this.teleportTimer <= 0) {
                    this.x = Math.random() * (canvas.width - this.width);
                    this.y = Math.random() * (canvas.height / 4) + 20;
                    this.teleportTimer = 150 + Math.random() * 100;
                    this.alpha = 0;
                }

                if (this.alpha < 1) this.alpha += 0.05;

                this.shootTimer--;
                if (this.shootTimer <= 0 && this.alpha >= 1) {
                    const dx = player.x - this.x;
                    const dy = player.y - this.y;
                    const angle = Math.atan2(dy, dx);
                    const speed = 4;
                    enemyBullets.push(new Bullet(this.x + this.width / 2, this.y + this.height / 2, 10, 10, Math.sin(angle) * speed, 'enemy', Math.cos(angle) * speed));
                    this.shootTimer = 90;
                }
            }
        }

        // 小Boss 3: 蜂巢
        class SwarmHive extends Enemy {
            constructor(x, y) {
                super(x, y, 100, 100, 40, 10000); // 血量x2
                this.baseY = y;
                this.angle = 0;
                this.spawnTimer = 120;
            }
            draw() {
                // 六边形母巢
                ctx.fillStyle = '#556b2f'; // 暗橄榄绿
                ctx.beginPath();
                ctx.moveTo(this.x + 25, this.y);
                ctx.lineTo(this.x + 75, this.y);
                ctx.lineTo(this.x + 100, this.y + 50);
                ctx.lineTo(this.x + 75, this.y + 100);
                ctx.lineTo(this.x + 25, this.y + 100);
                ctx.lineTo(this.x, this.y + 50);
                ctx.closePath();
                ctx.fill();

                // 孵化口
                ctx.fillStyle = '#ff8c00';
                ctx.beginPath();
                ctx.arc(this.x + 50, this.y + 50, 20 + Math.sin(this.angle) * 5, 0, Math.PI * 2);
                ctx.fill();
            }
            update() {
                // 8字形移动
                this.angle += 0.02; // 提升移动速度
                this.x = canvas.width / 2 - 50 + Math.sin(this.angle) * 100;
                this.y = 80 + Math.cos(this.angle * 2) * 30;


                this.spawnTimer--;
                if (this.spawnTimer <= 0) {
                    const type = Math.random() < 0.6 ? KamikazeDrone : SwarmMinion;
                    if (type === SwarmMinion) {
                        const swarmLeader = { 
                            x: this.x + 50, y: this.y + 100, 
                            update: function() { this.y += 1.5; if(this.y > canvas.height + 100) this.markedForDeletion = true;}, 
                            markedForDeletion: false
                        };
                        enemies.push(swarmLeader);
                        for(let i=0; i<3; i++) enemies.push(new SwarmMinion(this.x, this.y, currentWave, swarmLeader));
                    } else {
                        enemies.push(new KamikazeDrone(this.x + Math.random() * this.width, this.y + this.height));
                    }
                    this.spawnTimer = 90;
                }
            }
            takeDamage(damage, bullet) {
                 if (bullet && checkCollision(bullet, this)) {
                    return super.takeDamage(damage);
                }
                 // For laser
                if (!bullet) {
                     return super.takeDamage(damage);
                }
                return false;
            }
        }


        class FinalBoss extends Enemy {
             constructor(x, y) {
                super(x, y, 160, 120, 0, 50000); // HP会根据阶段计算
                this.speedY = 0.5;
                this.speedX = 1.2;
                this.phase = 1;
                this.turrets = [
                    { x: -20, y: 40, hp: 20, maxHp: 20, shootType: 'straight', cooldown: 100, timer: 100, destroyed: false }, // 血量x2
                    { x: 160, y: 40, hp: 20, maxHp: 20, shootType: 'triple', cooldown: 150, timer: 150, destroyed: false }, // 血量x2
                    { x: 20, y: 100, hp: 20, maxHp: 20, shootType: 'fan', cooldown: 200, timer: 200, destroyed: false }, // 血量x2
                    { x: 120, y: 100, hp: 20, maxHp: 20, shootType: 'tracking', cooldown: 250, timer: 250, destroyed: false }, // 血量x2
                ];
                this.hp = this.turrets.reduce((sum, t) => sum + t.hp, 0); // 阶段1的HP是炮台总血量
                this.maxHp = this.hp;
                 this.spiralAngle = 0;
                 this.laserTimer = 0;
            }
            draw() {
                 ctx.fillStyle = '#222';
                ctx.fillRect(this.x, this.y, 160, 120);
                ctx.fillStyle = '#8a2be2';
                ctx.beginPath();
                ctx.ellipse(this.x + 80, this.y + 60, 40, 55, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#000';
                 ctx.beginPath();
                ctx.ellipse(this.x + 80, this.y + 60, 15, 30, 0, 0, Math.PI * 2);
                ctx.fill();
                
                this.turrets.forEach(turret => {
                    if (!turret.destroyed) {
                        ctx.fillStyle = '#666';
                        ctx.fillRect(this.x + turret.x, this.y + turret.y, 20, 20);
                        if(turret.timer < 30) {
                             ctx.fillStyle = '#f00';
                             ctx.fillRect(this.x + turret.x + 5, this.y + turret.y + 5, 10, 10);
                        }
                    }
                });
            }
            update() {
                // Phase 1: Destroy Turrets
                if (this.phase === 1) {
                    if (this.y < 50) this.y += this.speedY;
                    this.x += this.speedX;
                    if (this.x < 0 || this.x > canvas.width - this.width) this.speedX *= -1;
                    
                    let allDestroyed = true;
                    this.turrets.forEach(turret => {
                        if (!turret.destroyed) {
                            allDestroyed = false;
                            turret.timer--;
                            if (turret.timer <= 0) {
                                this.shoot(turret);
                                turret.timer = turret.cooldown;
                            }
                        }
                    });

                    if (allDestroyed) {
                        this.phase = 2;
                        this.hp = 60; this.maxHp = 60; // 血量x2
                        createExplosion(this.x + this.width/2, this.y + this.height/2, '#00ffff', 40); // 阶段切换视觉提示
                    }
                } 
                // Phase 2: Spiral Bullets
                else if (this.phase === 2) {
                     this.x += (Math.random() - 0.5) * 10;
                     this.y += (Math.random() - 0.5) * 6;
                     this.x = Math.max(0, Math.min(canvas.width - this.width, this.x));
                     this.y = Math.max(20, Math.min(100, this.y));
                     
                     const bulletsPerFrame = 5;
                     for(let i=0; i<bulletsPerFrame; i++) {
                         const angle = this.spiralAngle + (i * (2*Math.PI/bulletsPerFrame));
                         const speed = 4;
                         enemyBullets.push(new Bullet(this.x+80, this.y+60, 4, 4, Math.sin(angle)*speed, 'enemy', Math.cos(angle)*speed));
                     }
                     this.spiralAngle += 0.1;
                     if(this.hp < this.maxHp / 2) { // Enter phase 3 at half HP
                         this.phase = 3;
                         this.laserTimer = 180; // 3 second charge up
                     }
                }
                // Phase 3: Laser Beams and Summons
                else if (this.phase === 3) {
                    this.laserTimer--;
                    if(this.laserTimer > 60) { // Charging
                         ctx.fillStyle = 'rgba(255, 0, 0, 0.1)';
                         ctx.fillRect(0, this.y + 60, canvas.width, 20);
                    } else if (this.laserTimer > 0) { // Firing
                         ctx.fillStyle = 'rgba(255, 0, 0, 0.8)';
                         ctx.fillRect(0, this.y + 60, canvas.width, 20);
                         if(checkCollision(player, {x:0, y: this.y+60, width: canvas.width, height: 20})) player.takeDamage();
                    } else { // Cooldown and summon
                        if(enemies.filter(e => e instanceof GhostInterceptor).length < 2) {
                           enemies.push(new GhostInterceptor(Math.random() * canvas.width, -50));
                        }
                        this.laserTimer = 300; // 5 second cooldown
                    }
                }
            }
            shoot(turret) {
                 const bx = this.x + turret.x + 10;
                const by = this.y + turret.y + 20;
                 switch(turret.shootType) {
                    case 'straight': {
                        const dx = (player.x + player.width / 2) - bx;
                        const dy = (player.y + player.height / 2) - by;
                        const angle = Math.atan2(dy, dx);
                        const speed = 4;
                        enemyBullets.push(new Bullet(bx, by, 8, 8, Math.sin(angle) * speed, 'enemy', Math.cos(angle) * speed));
                        break;
                    }
                    case 'triple': {
                        const dx = (player.x + player.width / 2) - bx;
                        const dy = (player.y + player.height / 2) - by;
                        const centerAngle = Math.atan2(dy, dx);
                        const spread = 0.3;
                        const speed = 5;
                         for(let i = -1; i <= 1; i++) {
                            const angle = centerAngle + (i * spread);
                            enemyBullets.push(new Bullet(bx, by, 5, 5, Math.sin(angle) * speed, 'enemy', Math.cos(angle) * speed));
                         }
                        break;
                    }
                    case 'fan': {
                        const dx = (player.x + player.width / 2) - bx;
                        const dy = (player.y + player.height / 2) - by;
                        const centerAngle = Math.atan2(dy, dx);
                        const spread = 0.2;
                        const speed = 3;
                        for(let i = -2; i <= 2; i++) {
                            const angle = centerAngle + (i * spread);
                            enemyBullets.push(new Bullet(bx, by, 6, 6, Math.sin(angle) * speed, 'enemy', Math.cos(angle) * speed));
                        }
                        break;
                    }
                    case 'tracking': {
                        const dx = player.x - bx;
                        const dy = player.y - by;
                        const angle = Math.atan2(dy, dx);
                        const speed = 3.5;
                        enemyBullets.push(new Bullet(bx, by, 7, 7, Math.sin(angle) * speed, 'enemy', Math.cos(angle) * speed));
                        break;
                    }
                }
            }
            takeDamage(damage, bullet) {
                 if(this.phase === 1 && bullet) {
                     let hitTurret = false;
                     this.turrets.forEach(turret => {
                         if(!turret.destroyed && checkCollision(bullet, {x: this.x + turret.x, y: this.y + turret.y, width: 20, height: 20})) {
                             turret.hp -= damage;
                             this.hp -= damage; // 攻击炮台时，Boss总血量也减少
                             if(turret.hp <= 0) {
                                 turret.destroyed = true;
                                 createExplosion(this.x + turret.x + 10, this.y + turret.y + 10, '#ff8c00', 20);
                                 score += 1500;
                                 playHitSound();
                             }
                             hitTurret = true;
                         }
                     });
                     return hitTurret;
                 } else if (this.phase > 1) { 
                      const core = {x: this.x + 40, y: this.y + 30, width: 80, height: 60};
                      if(!bullet || checkCollision(bullet, core)) { 
                          this.hp -= damage;
                           if (this.hp <= 0 && !this.markedForDeletion) {
                                this.markedForDeletion = true;
                                score += this.scoreValue;
                                createExplosion(this.x + this.width / 2, this.y + this.height / 2, '#ff8c00', 100);
                                gameState = GAME_STATE.VICTORY;
                                addHighScore(score); // 游戏胜利时记录分数
                                playHitSound();
                           }
                           return true;
                      }
                 }
                return false;
            }
        }
        
        // 道具类
        class PowerUp {
            constructor(x, y, type) {
                this.x = x;
                this.y = y;
                this.size = 20;
                this.type = type;
                this.speedY = 2;
                this.markedForDeletion = false;
                this.angle = 0;
            }

            draw() {
                ctx.save();
                ctx.translate(this.x + this.size/2, this.y + this.size/2);
                ctx.rotate(this.angle);
                ctx.translate(-(this.x + this.size/2), -(this.y + this.size/2));

                if (this.type === 'multiShot') {
                    ctx.fillStyle = '#ff0000'; // 红色
                    ctx.fillRect(this.x, this.y, this.size, this.size);
                    ctx.fillStyle = '#ff8888';
                    ctx.fillRect(this.x + 4, this.y + 4, this.size - 8, this.size - 8);
                } else if (this.type === 'laser') {
                    ctx.fillStyle = '#0000ff'; // 蓝色
                    ctx.beginPath();
                    ctx.moveTo(this.x + this.size / 2, this.y);
                    ctx.lineTo(this.x + this.size, this.y + this.size);
                    ctx.lineTo(this.x, this.y + this.size);
                    ctx.closePath();
                    ctx.fill();
                } else if (this.type === 'shield') {
                    ctx.fillStyle = '#00ff00'; // 绿色
                    ctx.fillRect(this.x, this.y + this.size/4, this.size, this.size/2);
                    ctx.fillRect(this.x + this.size/4, this.y, this.size/2, this.size);
                } else if (this.type === 'health') {
                    // 绘制爱心
                    ctx.fillStyle = '#ff69b4'; // 亮粉色
                    ctx.beginPath();
                    ctx.moveTo(this.x + this.size / 2, this.y + this.size / 4);
                    ctx.quadraticCurveTo(this.x, this.y, this.x, this.y + this.size / 2);
                    ctx.quadraticCurveTo(this.x, this.y + this.size, this.x + this.size / 2, this.y + this.size);
                    ctx.quadraticCurveTo(this.x + this.size, this.y + this.size, this.x + this.size, this.y + this.size / 2);
                    ctx.quadraticCurveTo(this.x + this.size, this.y, this.x + this.size / 2, this.y + this.size / 4);
                    ctx.fill();
                } else if (this.type === 'fireRate') {
                    // 绘制闪电
                    ctx.fillStyle = '#ffff00'; // 黄色
                    ctx.beginPath();
                    ctx.moveTo(this.x + this.size * 0.5, this.y);
                    ctx.lineTo(this.x + this.size * 0.2, this.y + this.size * 0.6);
                    ctx.lineTo(this.x + this.size * 0.4, this.y + this.size * 0.6);
                    ctx.lineTo(this.x + this.size * 0.1, this.y + this.size);
                    ctx.lineTo(this.x + this.size * 0.8, this.y + this.size * 0.4);
                    ctx.lineTo(this.x + this.size * 0.6, this.y + this.size * 0.4);
                    ctx.closePath();
                    ctx.fill();
                }
                 ctx.restore();
            }

            update() {
                this.y += this.speedY;
                this.angle += 0.05;
                if (this.y > canvas.height) this.markedForDeletion = true;
            }
        }

        // 粒子效果类
        class Particle {
            constructor(x, y, size, color, speedX, speedY, life) {
                this.x = x;
                this.y = y;
                this.size = size;
                this.color = color;
                this.speedX = speedX + (Math.random() - 0.5) * 4;
                this.speedY = speedY + (Math.random() - 0.5) * 4;
                this.life = life;
                this.markedForDeletion = false;
            }

            draw() {
                ctx.globalAlpha = this.life / 20;
                ctx.fillStyle = this.color;
                ctx.fillRect(this.x, this.y, this.size, this.size);
                ctx.globalAlpha = 1;
            }

            update() {
                this.x += this.speedX;
                this.y += this.speedY;
                this.life--;
                if (this.life <= 0) this.markedForDeletion = true;
            }
        }

        // --- 游戏逻辑函数 ---

        // 新增：基地受损处理函数
        function handleBaseDamage() {
            if (gameState !== GAME_STATE.PLAYING) return; // 仅在游戏进行时扣血
            baseHp--;
            if (baseHp <= 0) {
                gameState = GAME_STATE.GAME_OVER;
                addHighScore(score);
            }
        }

        // 高分记录函数
        function getHighScores() {
            const scores = localStorage.getItem('pixelStarHighScores');
            return scores ? JSON.parse(scores) : [];
        }

        function saveHighScores(scores) {
            localStorage.setItem('pixelStarHighScores', JSON.stringify(scores));
        }

        function addHighScore(newScore) {
            if (newScore === 0) return;
            const scores = getHighScores();
            scores.push(newScore);
            scores.sort((a, b) => b - a);
            const newHighScores = scores.slice(0, 5);
            saveHighScores(newHighScores);
        }

        function initGame() {
            player = new Player();
            score = 0;
            baseHp = 5;
            currentWave = 0;
            enemies = [];
            bullets = [];
            enemyBullets = [];
            powerUps = [];
            particles = [];
            
            // 创建背景
            if (backgroundStars.length === 0) {
                for (let i = 0; i < 100; i++) {
                    backgroundStars.push({
                        x: Math.random() * canvas.width,
                        y: Math.random() * canvas.height,
                        size: Math.random() * 2,
                        speed: Math.random() * 0.5 + 0.2
                    });
                }
                 for (let i = 0; i < 5; i++) {
                     backgroundNebulas.push({
                        x: Math.random() * canvas.width,
                        y: Math.random() * canvas.height,
                        size: Math.random() * 200 + 100,
                        speed: 0.2,
                        color: `rgba(${Math.random()*100+100}, 50, ${Math.random()*100+155}, 0.2)`
                     });
                 }
                 for (let i = 0; i < 20; i++) {
                    backgroundAsteroids.push({
                        x: Math.random() * canvas.width,
                        y: Math.random() * canvas.height,
                        size: Math.random() * 10 + 5,
                        speed: 0.8,
                    });
                 }
            }
            startNextWave();
        }
        
        function startNextWave() {
            currentWave++;
            if (currentWave > waveConfigs.length) {
                return;
            }
            
            waveSpawners = [];
            const waveConfig = waveConfigs[currentWave - 1];
            
            waveConfig.enemies.forEach(group => {
                waveSpawners.push({
                    type: group.type,
                    count: group.count,
                    remaining: group.count,
                    spawnDelay: group.spawnDelay,
                    timer: group.spawnDelay,
                    x: group.x,
                    y: group.y
                });
            });

            gameState = GAME_STATE.PLAYING;
        }

        // 全新设计的关卡流程
        const waveConfigs = [
            // 前期关卡 (趣味性增强)
            { isBossWave: false, enemies: [ { type: PulseScout, count: 10, x: 'random', y: -50, spawnDelay: 100 }, { type: KamikazeDrone, count: 8, x: 'random', y: -50, spawnDelay: 150 }, { type: SpiralFighter, count: 4, x: 'random', y: -80, spawnDelay: 250 } ]},
            { isBossWave: false, enemies: [ { type: PulseScout, count: 10, x: 'random', y: -50, spawnDelay: 150 }, { type: 'swarm', count: 15, y: -80, spawnDelay: 100}, { type: KamikazeDrone, count: 10, x: 'random', y: -50, spawnDelay: 200 }, { type: SpiralFighter, count: 5, x: 'random', y: -80, spawnDelay: 300 }, { type: BarrierSentinel, count: 1, x: 'random', y: -60, spawnDelay: 400 } ]},
            { isBossWave: true, enemies: [ { type: Juggernaut, count: 1, x: canvas.width/2 - 60, y: -100, spawnDelay: 100 } ]}, // Mini-Boss 1
            // 中期关卡 (挑战性提升)
            { isBossWave: false, enemies: [ { type: BarrierSentinel, count: 2, x: 'random', y: -60, spawnDelay: 300 }, { type: 'swarm', count: 20, y: -80, spawnDelay: 120}, { type: PulseScout, count: 10, x: 'random', y: -50, spawnDelay: 180 }, { type: KamikazeDrone, count: 10, x: 'random', y: -50, spawnDelay: 150 }, { type: SpiralFighter, count: 5, x: 'random', y: -80, spawnDelay: 250 } ]},
            { isBossWave: false, enemies: [ { type: GhostInterceptor, count: 2, x: 'random', y: -50, spawnDelay: 300 }, { type: KamikazeDrone, count: 15, x: 'random', y: -50, spawnDelay: 100 }, { type: SpiralFighter, count: 8, x: 'random', y: -80, spawnDelay: 200 }, { type: PulseScout, count: 10, x: 'random', y: -50, spawnDelay: 150 }, { type: HeavyCruiser, count: 1, x: 'random', y: -80, spawnDelay: 500 } ]},
            { isBossWave: true, enemies: [ { type: Phantom, count: 1, x: canvas.width/2 - 40, y: 50, spawnDelay: 100 } ]}, // Mini-Boss 2
            // 后期关卡 (更高挑战)
            { isBossWave: false, enemies: [ { type: HeavyCruiser, count: 2, x: 'random', y: -80, spawnDelay: 400 }, { type: SpiralFighter, count: 15, x: 'random', y: -80, spawnDelay: 100 }, { type: 'swarm', count: 20, y: -80, spawnDelay: 150 }, { type: BarrierSentinel, count: 2, x: 'random', y: -60, spawnDelay: 300 }, { type: PulseScout, count: 15, x: 'random', y: -50, spawnDelay: 120 } ]},
            { isBossWave: false, enemies: [ { type: GhostInterceptor, count: 3, x: 'random', y: -50, spawnDelay: 200 }, { type: BarrierSentinel, count: 2, x: 'random', y: -60, spawnDelay: 500 }, { type: HeavyCruiser, count: 1, x: 'random', y: -80, spawnDelay: 400 }, { type: KamikazeDrone, count: 20, x: 'random', y: -50, spawnDelay: 90 }, { type: SpiralFighter, count: 10, x: 'random', y: -80, spawnDelay: 150 } ]},
            { isBossWave: true, enemies: [ { type: SwarmHive, count: 1, x: canvas.width/2 - 50, y: -120, spawnDelay: 100 } ]}, // Mini-Boss 3
            // 最终关卡
            { isBossWave: true, enemies: [{ type: FinalBoss, count: 1, x: canvas.width/2 - 80, y: -150, spawnDelay: 1000 }] } // Final Boss
        ];

        function checkCollision(rect1, rect2) {
            return rect1.x < rect2.x + rect2.width &&
                   rect1.x + rect1.width > rect2.x &&
                   rect1.y < rect2.y + rect2.height &&
                   rect1.y + rect1.height > rect2.y;
        }

        function handleCollisions() {
            // 激光伤害判定
            if (player.powerUpTimers.laser > 0) {
                const laserHitbox = {
                    x: player.x + player.width / 2 - 4,
                    y: 0,
                    width: 8,
                    height: player.y
                };
                enemies.forEach(enemy => {
                    // 只对有实体的敌人进行碰撞检测
                    if (enemy.draw && checkCollision(laserHitbox, enemy)) {
                        // Bosses have special takeDamage logic for laser (no bullet object)
                        if (enemy instanceof FinalBoss || enemy instanceof Juggernaut || enemy instanceof Phantom || enemy instanceof SwarmHive || enemy instanceof BarrierSentinel) {
                             enemy.takeDamage(0.2, laserHitbox);
                        } else {
                            enemy.takeDamage(0.2); 
                        }
                    }
                });
            }
            // 玩家子弹 vs 敌人
            bullets.forEach(bullet => {
                enemies.forEach(enemy => {
                    if (enemy.draw && checkCollision(bullet, enemy)) {
                         // takeDamage returns true if the bullet should be destroyed
                        if (enemy.takeDamage(1, bullet)) { 
                            bullet.markedForDeletion = true;
                        }
                    }
                });
            });

            // 敌人子弹 vs 玩家
            enemyBullets.forEach(bullet => {
                if (checkCollision(bullet, player)) {
                    bullet.markedForDeletion = true;
                    player.takeDamage();
                }
            });
            
            // 敌人 vs 玩家 (撞击)
            enemies.forEach(enemy => {
                 if (enemy.draw && checkCollision(enemy, player)) {
                    enemy.markedForDeletion = true;
                    player.takeDamage();
                 }
            });

            // 道具 vs 玩家
            powerUps.forEach(powerUp => {
                const powerUpRect = {
                    x: powerUp.x,
                    y: powerUp.y,
                    width: powerUp.size,
                    height: powerUp.size
                };
                if (checkCollision(powerUpRect, player)) {
                    powerUp.markedForDeletion = true;
                    applyPowerUp(powerUp.type);
                }
            });
        }
        
        function applyPowerUp(type) {
             playPowerUpSound();
             if (type === 'multiShot') {
                player.powerUpTimers.multiShot = 900; // 15秒
                player.powerUpTimers.laser = 0; // 互斥
             } else if (type === 'laser') {
                player.powerUpTimers.laser = 480; // 8秒
                player.powerUpTimers.multiShot = 0; // 互斥
             } else if (type === 'shield') {
                if(player.shield < 3) player.shield++;
             } else if (type === 'health') {
                if(player.hp < player.maxHp) player.hp++;
                if(baseHp < maxBaseHp) baseHp++; // 同时恢复基地生命值
             } else if (type === 'fireRate') {
                player.powerUpTimers.fireRate = 600; // 10秒
             }
        }
        
        function createExplosion(x, y, color, count = 20) {
            for (let i = 0; i < count; i++) {
                particles.push(new Particle(x, y, Math.random() * 3 + 1, color, 0, 0, 20));
            }
        }
        
        // --- 绘制函数 ---

        function drawUI() {
            // 使用基于画布宽度的动态字体大小
            const uiFontSize = Math.min(20, Math.floor(canvasWidth / 25));
            ctx.fillStyle = '#fff';
            ctx.font = `${uiFontSize}px "Press Start 2P"`;
            
            // --- 左上角：血量 ---
            ctx.textAlign = 'left';
            const heartSize = Math.floor(canvasWidth / 20);
            const heartSpacing = Math.floor(canvasWidth / 18);
            for (let i = 0; i < player.maxHp; i++) {
                // 绘制血量槽 (爱心)
                const heartX = 15 + i * heartSpacing;
                const heartY = 15;
                const size = heartSize;

                ctx.save();
                // 如果是当前血量，则画实心；否则画空心
                if (i < player.hp) {
                    ctx.fillStyle = '#ff69b4'; // 实心颜色
                } else {
                    ctx.strokeStyle = '#ff69b4'; // 空心颜色
                    ctx.lineWidth = 2;
                }
                
                ctx.beginPath();
                ctx.moveTo(heartX + size / 2, heartY + size / 4);
                ctx.quadraticCurveTo(heartX, heartY, heartX, heartY + size / 2);
                ctx.quadraticCurveTo(heartX, heartY + size, heartX + size / 2, heartY + size);
                ctx.quadraticCurveTo(heartX + size, heartY + size, heartX + size, heartY + size / 2);
                ctx.quadraticCurveTo(heartX + size, heartY, heartX + size / 2, heartY + size / 4);
                
                if (i < player.hp) {
                    ctx.fill();
                } else {
                    ctx.stroke();
                }
                ctx.restore();
            }

            // 新增：绘制基地生命值 (黄色护盾图标)
            const baseHpIconSize = Math.floor(canvasWidth / 22);
            const baseHpIconSpacing = Math.floor(canvasWidth / 20);
            const baseHpY = 15 + heartSize + 10;
            for (let i = 0; i < maxBaseHp; i++) {
                const iconX = 15 + i * baseHpIconSpacing;
                ctx.save();
                if (i < baseHp) {
                    ctx.fillStyle = '#ffff00'; // 黄色
                } else {
                    ctx.strokeStyle = '#ffff00';
                    ctx.lineWidth = 2;
                }

                // 绘制护盾形状
                ctx.beginPath();
                ctx.moveTo(iconX + baseHpIconSize / 2, baseHpY); // Top point
                ctx.lineTo(iconX + baseHpIconSize, baseHpY + baseHpIconSize * 0.3);
                ctx.lineTo(iconX + baseHpIconSize, baseHpY + baseHpIconSize);
                ctx.lineTo(iconX, baseHpY + baseHpIconSize);
                ctx.lineTo(iconX, baseHpY + baseHpIconSize * 0.3);
                ctx.closePath();

                if (i < baseHp) {
                    ctx.fill();
                } else {
                    ctx.stroke();
                }
                ctx.restore();
            }


            // --- 右上角 & 中间顶部：关卡和分数 ---
            const isBossWave = currentWave > 0 && waveConfigs[currentWave-1].isBossWave;

            if (isBossWave) {
                // Boss战时：分数在右上角，BOSS标题在中间
                ctx.fillStyle = '#fff';
                ctx.textAlign = 'right';
                ctx.fillText(`SCORE: ${score}`, canvas.width - 20, 30);
                
                ctx.fillStyle = '#f00';
                ctx.textAlign = 'center';
                ctx.fillText(`BOSS`, canvas.width / 2, 30);

            } else if (currentWave > 0) {
                // 普通关卡：关卡和分数堆叠在右上角
                ctx.fillStyle = '#fff';
                ctx.textAlign = 'right';
                const textX = canvas.width - 20;
                const textY1 = 30;
                const textY2 = textY1 + uiFontSize + 8; // 垂直间距
                ctx.fillText(`WAVE: ${currentWave}`, textX, textY1);
                ctx.fillText(`SCORE: ${score}`, textX, textY2);
            }


            // --- Boss血条 ---
            const boss = enemies.find(e => e instanceof Juggernaut || e instanceof Phantom || e instanceof SwarmHive || e instanceof FinalBoss);
            if (boss) {
                const barWidth = canvas.width * 0.8;
                const barHeight = Math.min(20, canvas.width / 20);
                const x = canvas.width / 2 - barWidth / 2;
                const y = isBossWave ? 55 : 80; // Boss战时血条位置高一些
                const hpPercent = boss.hp > 0 ? (boss.hp / boss.maxHp) : 0;
                
                ctx.fillStyle = '#555';
                ctx.fillRect(x, y, barWidth, barHeight);
                
                ctx.fillStyle = '#f00';
                ctx.fillRect(x, y, barWidth * hpPercent, barHeight);

                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                ctx.strokeRect(x, y, barWidth, barHeight);
            }
        }
        
        function drawBackground() {
            // 根据关卡改变背景
            let bgColor = '#080818';
            if(currentWave >= 4 && currentWave <= 6) { // 幽暗星云
                 bgColor = '#200020';
            } else if (currentWave >= 7 && currentWave <= 9) { // 敌军领域
                 bgColor = '#301000';
            } else if (currentWave >= 10) { // 虚空核心
                 bgColor = '#000';
            }
            ctx.fillStyle = bgColor;
            ctx.fillRect(0,0,canvas.width,canvas.height);
            
            // 绘制星辰
            backgroundStars.forEach(star => {
                star.y += star.speed;
                if(star.y > canvas.height) {
                    star.y = 0;
                    star.x = Math.random() * canvas.width;
                }
                ctx.fillStyle = '#fff';
                ctx.fillRect(star.x, star.y, star.size, star.size);
            });
            
             // 绘制星云
            if (currentWave >= 4 && currentWave <= 6) {
                backgroundNebulas.forEach(nebula => {
                    nebula.y += nebula.speed;
                    if(nebula.y > canvas.height + nebula.size) {
                        nebula.y = -nebula.size;
                        nebula.x = Math.random() * canvas.width;
                    }
                    ctx.fillStyle = nebula.color;
                    ctx.beginPath();
                    ctx.arc(nebula.x, nebula.y, nebula.size, 0, Math.PI * 2);
                    ctx.fill();
                });
            }
            
            // 绘制陨石
            if (currentWave >= 1 && currentWave <= 3) {
                 backgroundAsteroids.forEach(roid => {
                    roid.y += roid.speed;
                    if(roid.y > canvas.height) {
                        roid.y = 0;
                        roid.x = Math.random() * canvas.width;
                    }
                    ctx.fillStyle = '#555';
                    ctx.fillRect(roid.x, roid.y, roid.size, roid.size);
                });
            }
        }
        
        // --- 重绘屏幕函数 ---
        function drawStartScreen() {
            drawBackground();
            const titleFontSize = Math.min(40, Math.floor(canvasWidth / 10));
            ctx.textAlign = 'center';
            ctx.fillStyle = '#fff';

            // 标题辉光效果
            ctx.shadowColor = '#00ffff';
            ctx.shadowBlur = 10;
            
            ctx.font = `${titleFontSize}px "Press Start 2P"`;
            ctx.fillText('Pixel Star', canvas.width / 2, canvas.height * 0.15);
            ctx.fillText('Guardian', canvas.width / 2, canvas.height * 0.15 + titleFontSize + 10);
            
            // 重置辉光
            ctx.shadowBlur = 0;

            // 绘制按钮
            const buttonWidth = canvasWidth * 0.6;
            const buttonHeight = 50;
            const centerX = canvasWidth / 2 - buttonWidth / 2;

            startScreenButtons.start = {x: centerX, y: canvas.height * 0.35, width: buttonWidth, height: buttonHeight, text: "开始游戏"};
            startScreenButtons.highScores = {x: centerX, y: canvas.height * 0.35 + buttonHeight + 20, width: buttonWidth, height: buttonHeight, text: "高分榜"};
            
            drawButton(startScreenButtons.start, isInside(mouse, startScreenButtons.start));
            drawButton(startScreenButtons.highScores, isInside(mouse, startScreenButtons.highScores));

            // 绘制道具说明
            drawPowerUpDescriptions();
        }

        function drawPowerUpDescriptions() {
            const descriptions = [
                { type: 'multiShot', text: '散射' },
                { type: 'fireRate', text: '速射' },
                { type: 'laser', text: '激光' },
                { type: 'shield', text: '护盾' },
                { type: 'health', text: '维修' }
            ];

            const containerWidth = canvasWidth * 0.9;
            const containerHeight = canvasHeight * 0.22; // 减小高度
            const containerX = canvasWidth / 2 - containerWidth / 2;
            const containerY = canvas.height * 0.65; // 调整Y坐标

            // 绘制容器
            ctx.save();
            ctx.strokeStyle = '#33f';
            ctx.lineWidth = 2;
            ctx.strokeRect(containerX, containerY, containerWidth, containerHeight);
            ctx.fillStyle = 'rgba(10, 10, 30, 0.5)';
            ctx.fillRect(containerX, containerY, containerWidth, containerHeight);
            ctx.restore();

            const titleFontSize = Math.min(16, Math.floor(canvasWidth / 30));
            ctx.font = `${titleFontSize}px "Press Start 2P"`;
            ctx.fillStyle = '#aaa';
            ctx.textAlign = 'center';
            ctx.fillText('--- 道具说明 ---', canvas.width / 2, containerY + titleFontSize + 5);
            
            const textFontSize = Math.min(12, Math.floor(canvasWidth / 40));
            ctx.font = `${textFontSize}px "Press Start 2P"`;
            ctx.textBaseline = 'middle';

            const dummyPowerUp = new PowerUp(0, 0, '');
            const itemCount = descriptions.length;
            const itemSpacing = containerWidth / (itemCount + 1);

            descriptions.forEach((desc, index) => {
                const itemCenterX = containerX + itemSpacing * (index + 1);
                
                const iconSize = 24;
                const iconY = containerY + containerHeight / 2 - iconSize / 2 - 5;
                const textY = iconY + iconSize + 10;
                
                // 绘制图标
                dummyPowerUp.x = itemCenterX - iconSize / 2;
                dummyPowerUp.y = iconY;
                dummyPowerUp.type = desc.type;
                dummyPowerUp.angle = 0; 
                dummyPowerUp.size = iconSize;
                dummyPowerUp.draw();

                // 绘制文本
                ctx.fillStyle = '#fff';
                ctx.textAlign = 'center';
                ctx.fillText(desc.text, itemCenterX, textY);
            });
        }
        
        function drawHighScoresScreen() {
            drawBackground();
            const titleFontSize = Math.min(30, Math.floor(canvasWidth / 12));
            const scoreFontSize = Math.min(24, Math.floor(canvasWidth / 18));
             ctx.textAlign = 'center';
            ctx.fillStyle = '#fff';
            ctx.font = `${titleFontSize}px "Press Start 2P"`;
            ctx.fillText('高分榜', canvas.width / 2, canvas.height * 0.15);

            const highScores = getHighScores();
            ctx.font = `${scoreFontSize}px "Press Start 2P"`;
            if (highScores.length === 0) {
                ctx.fillText('暂无记录', canvas.width / 2, canvas.height / 2);
            } else {
                highScores.forEach((score, index) => {
                    const yPos = canvas.height * 0.3 + index * (scoreFontSize + 20);
                    ctx.fillText(`${index + 1}. ${score}`, canvas.width / 2, yPos);
                });
            }

            const buttonWidth = canvasWidth * 0.5;
            const buttonHeight = 50;
            const centerX = canvasWidth / 2 - buttonWidth / 2;
            highScoresScreenButtons.back = {x: centerX, y: canvas.height * 0.8, width: buttonWidth, height: buttonHeight, text: "返回"};
            drawButton(highScoresScreenButtons.back, isInside(mouse, highScoresScreenButtons.back));
        }

        function drawGameOverScreen() {
            ctx.fillStyle = 'rgba(0,0,0,0.7)';
            ctx.fillRect(0,0,canvas.width,canvas.height);
            const titleFontSize = Math.min(40, Math.floor(canvasWidth / 10));
            const subTitleFontSize = Math.min(20, Math.floor(canvasWidth / 22));
            ctx.textAlign = 'center';
            ctx.fillStyle = '#f00';
            ctx.font = `${titleFontSize}px "Press Start 2P"`;
            ctx.fillText('GAME OVER', canvas.width / 2, canvas.height / 2 - 80);
            ctx.fillStyle = '#fff';
            ctx.font = `${subTitleFontSize}px "Press Start 2P"`;
            ctx.fillText(`FINAL SCORE: ${score}`, canvas.width / 2, canvas.height / 2 - 20);

            // 绘制按钮
            const buttonWidth = canvasWidth * 0.6;
            const buttonHeight = 50;
            const centerX = canvasWidth / 2 - buttonWidth / 2;
            const buttonY = canvas.height / 2 + 40;

            gameOverScreenButtons.restart = {x: centerX, y: buttonY, width: buttonWidth, height: buttonHeight, text: "重新开始"};
            gameOverScreenButtons.highScores = {x: centerX, y: buttonY + buttonHeight + 20, width: buttonWidth, height: buttonHeight, text: "高分榜"};
            
            drawButton(gameOverScreenButtons.restart, isInside(mouse, gameOverScreenButtons.restart));
            drawButton(gameOverScreenButtons.highScores, isInside(mouse, gameOverScreenButtons.highScores));
        }
        
        function drawVictoryScreen() {
            ctx.fillStyle = 'rgba(0,50,100,0.7)';
            ctx.fillRect(0,0,canvas.width,canvas.height);
            const titleFontSize = Math.min(40, Math.floor(canvasWidth / 10));
            const subTitleFontSize = Math.min(20, Math.floor(canvasWidth / 22));
            ctx.textAlign = 'center';
            ctx.fillStyle = '#0f0';
            ctx.font = `${titleFontSize}px "Press Start 2P"`;
            ctx.fillText('VICTORY!', canvas.width / 2, canvas.height / 2 - 80);
            ctx.fillStyle = '#fff';
            ctx.font = `${subTitleFontSize}px "Press Start 2P"`;
            ctx.fillText(`FINAL SCORE: ${score}`, canvas.width / 2, canvas.height / 2 - 20);
            
            // 绘制按钮
            const buttonWidth = canvasWidth * 0.6;
            const buttonHeight = 50;
            const centerX = canvasWidth / 2 - buttonWidth / 2;
            const buttonY = canvas.height / 2 + 40;

            victoryScreenButtons.restart = {x: centerX, y: buttonY, width: buttonWidth, height: buttonHeight, text: "重新开始"};
            victoryScreenButtons.highScores = {x: centerX, y: buttonY + buttonHeight + 20, width: buttonWidth, height: buttonHeight, text: "高分榜"};
            
            drawButton(victoryScreenButtons.restart, isInside(mouse, victoryScreenButtons.restart));
            drawButton(victoryScreenButtons.highScores, isInside(mouse, victoryScreenButtons.highScores));
        }

        function drawWaveTransition() {
            const titleFontSize = Math.min(30, Math.floor(canvasWidth / 15));
            ctx.textAlign = 'center';
            ctx.fillStyle = '#fff';
            ctx.font = `${titleFontSize}px "Press Start 2P"`;
            if (currentWave < waveConfigs.length) {
                const nextWaveConfig = waveConfigs[currentWave];
                ctx.fillText(`WAVE ${currentWave} CLEARED`, canvas.width / 2, canvas.height / 2 - 50);
                
                if (nextWaveConfig.isBossWave) {
                    ctx.fillStyle = '#f00';
                    ctx.fillText(`WARNING!`, canvas.width / 2, canvas.height / 2);
                    ctx.fillText(`BOSS APPROACHING`, canvas.width / 2, canvas.height / 2 + 40);
                } else {
                    ctx.fillText(`GET READY FOR`, canvas.width / 2, canvas.height / 2);
                    ctx.fillText(`WAVE ${currentWave + 1}`, canvas.width / 2, canvas.height / 2 + 40);
                }
            }
        }

        // --- 新增：菜单按钮和点击处理 ---
        let startScreenButtons = {};
        let highScoresScreenButtons = {};
        let gameOverScreenButtons = {};
        let victoryScreenButtons = {};

        function drawButton(button, isHovered = false) {
            ctx.fillStyle = isHovered ? '#666' : '#444';
            ctx.fillRect(button.x, button.y, button.width, button.height);
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 2;
            ctx.strokeRect(button.x, button.y, button.width, button.height);
            
            ctx.fillStyle = '#fff';
            const fontSize = button.fontSize || Math.min(20, Math.floor(canvasWidth / 22));
            ctx.font = `${fontSize}px "Press Start 2P"`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(button.text, button.x + button.width / 2, button.y + button.height / 2);
        }
        
        function getMousePos(canvas, evt) {
            const rect = canvas.getBoundingClientRect();
            return {
                x: evt.clientX - rect.left,
                y: evt.clientY - rect.top
            };
        }

        function isInside(pos, rect){
            if (!rect) return false;
            return pos.x > rect.x && pos.x < rect.x + rect.width && pos.y < rect.y + rect.height && pos.y > rect.y
        }

        function handleMenuClick(evt) {
            const mousePos = getMousePos(canvas, evt);

            if (gameState === GAME_STATE.START_SCREEN) {
                if (isInside(mousePos, startScreenButtons.start)) {
                    if (!audioInitialized) {
                        Tone.start().then(initializeAudio);
                    }
                    initGame();
                } else if (isInside(mousePos, startScreenButtons.highScores)) {
                    previousGameState = GAME_STATE.START_SCREEN;
                    gameState = GAME_STATE.HIGH_SCORES_SCREEN;
                }
            } else if (gameState === GAME_STATE.HIGH_SCORES_SCREEN) {
                if(isInside(mousePos, highScoresScreenButtons.back)) {
                    gameState = previousGameState;
                }
            } else if (gameState === GAME_STATE.GAME_OVER) {
                if (isInside(mousePos, gameOverScreenButtons.restart)) {
                    gameState = GAME_STATE.START_SCREEN;
                } else if (isInside(mousePos, gameOverScreenButtons.highScores)) {
                    previousGameState = GAME_STATE.GAME_OVER;
                    gameState = GAME_STATE.HIGH_SCORES_SCREEN;
                }
            } else if (gameState === GAME_STATE.VICTORY) {
                if (isInside(mousePos, victoryScreenButtons.restart)) {
                    gameState = GAME_STATE.START_SCREEN;
                } else if (isInside(mousePos, victoryScreenButtons.highScores)) {
                    previousGameState = GAME_STATE.VICTORY;
                    gameState = GAME_STATE.HIGH_SCORES_SCREEN;
                }
            }
        }


        // --- 主游戏循环 ---
        function gameLoop() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawBackground();

            let isHoveringButton = false;

            if (gameState === GAME_STATE.START_SCREEN) {
                drawStartScreen();
                if (isInside(mouse, startScreenButtons.start) || isInside(mouse, startScreenButtons.highScores)) {
                    isHoveringButton = true;
                }
                if (Object.values(keys).some(key => key)) {
                     if (!audioInitialized) {
                        Tone.start().then(initializeAudio);
                    }
                    setTimeout(initGame, 0); 
                    keys = {};
                }
            } else if (gameState === GAME_STATE.HIGH_SCORES_SCREEN) {
                drawHighScoresScreen();
                 if (isInside(mouse, highScoresScreenButtons.back)) {
                    isHoveringButton = true;
                }
            } else if (gameState === GAME_STATE.PLAYING) {
                player.update();
                player.draw();
                
                // 道具生成
                powerUpSpawnTimer--;
                if(powerUpSpawnTimer <= 0) {
                    powerUpSpawnTimer = POWERUP_SPAWN_INTERVAL + Math.random() * 300; // 10-15秒随机
                    if(Math.random() < 0.85) { // 85%概率生成
                        const powerUpTypes = ['multiShot', 'laser', 'shield', 'health', 'fireRate']; 
                        const type = powerUpTypes[Math.floor(Math.random() * powerUpTypes.length)];
                        const x = Math.random() * (canvas.width - 20);
                        powerUps.push(new PowerUp(x, -30, type));
                    }
                }

                // 敌人生成逻辑
                if (enemies.filter(e => e.draw).length < 3) {
                    for(const spawner of waveSpawners) {
                         if (spawner.remaining > 0) {
                            spawner.timer--;
                            if (spawner.timer <= 0) {
                                if (spawner.type === 'swarm') {
                                    const swarmLeader = { 
                                        x: Math.random() * (canvas.width - 200) + 100, 
                                        y: spawner.y,
                                        markedForDeletion: false,
                                        update: function() {
                                            this.y += 1.5;
                                            this.x += Math.sin(this.y * 0.02) * 2;
                                            if (this.y > canvas.height + 100) {
                                                this.markedForDeletion = true;
                                            }
                                        }
                                    };
                                    enemies.push(swarmLeader);
                                    for(let i = 0; i < spawner.count; i++) {
                                        const x = swarmLeader.x + (Math.random() - 0.5) * 100;
                                        const y = swarmLeader.y + (Math.random() - 0.5) * 100;
                                        enemies.push(new SwarmMinion(x, y, currentWave, swarmLeader));
                                    }
                                    spawner.remaining = 0;
                                } else {
                                    const x = spawner.x === 'random' ? Math.random() * (canvas.width - 40) : spawner.x;
                                    enemies.push(new spawner.type(x, spawner.y, currentWave));
                                    spawner.remaining--;
                                }
                                spawner.timer = spawner.spawnDelay;
                                break; 
                            }
                        }
                    }
                }

                [bullets, enemyBullets, enemies, powerUps, particles].forEach(arr => {
                    arr.forEach(item => {
                        item.update();
                        if(item.draw) item.draw(); 
                    });
                });

                handleCollisions();
                
                bullets = bullets.filter(b => !b.markedForDeletion);
                enemyBullets = enemyBullets.filter(b => !b.markedForDeletion);
                enemies = enemies.filter(e => !e.markedForDeletion); 
                powerUps = powerUps.filter(p => !p.markedForDeletion);
                particles = particles.filter(p => !p.markedForDeletion);
                
                drawUI();

                const isWaveSpawningComplete = waveSpawners.every(s => s.remaining === 0);
                if (enemies.filter(e => e.draw).length === 0 && isWaveSpawningComplete) {
                     if (currentWave < waveConfigs.length) {
                        gameState = GAME_STATE.WAVE_TRANSITION;
                        waveTransitionTimer = WAVE_TRANSITION_DELAY;
                     } 
                }

            } else if (gameState === GAME_STATE.WAVE_TRANSITION) {
                player.draw();
                drawUI();
                drawWaveTransition();
                waveTransitionTimer--;
                if (waveTransitionTimer <= 0) {
                    startNextWave();
                }
            } else if (gameState === GAME_STATE.GAME_OVER) {
                drawGameOverScreen();
                 if (isInside(mouse, gameOverScreenButtons.restart) || isInside(mouse, gameOverScreenButtons.highScores)) {
                    isHoveringButton = true;
                }
            } else if (gameState === GAME_STATE.VICTORY) {
                drawVictoryScreen();
                if (isInside(mouse, victoryScreenButtons.restart) || isInside(mouse, victoryScreenButtons.highScores)) {
                    isHoveringButton = true;
                }
            }
            
            canvas.style.cursor = isHoveringButton ? 'pointer' : 'default';
            requestAnimationFrame(gameLoop);
        }
        
        gameLoop();

    </script>
</body>
</html>

